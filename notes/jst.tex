\documentclass{article}
\usepackage{stmaryrd}
\usepackage[landscape]{geometry}
\usepackage{fullpage}
\usepackage{jst}
\usepackage{mathpartir}
\usepackage{notation}

\newcommand\Eval[2]{
  \FmtFam{
    {\left\llbracket\FmtTm{#1}\right\rrbracket}_{\FmtVal{#2}}
  }
}

\title{cubical evaluation semantics}
\author{Carlo Angiuli \and Jon Sterling}

\begin{document}
\maketitle

I've been thinking a bit more carefully about the evaluation semantics and the
semantic domain. What I think we want to do is take a term and an environment
and return a family of values (indexed in restrictions); but crucially, I think
it is important that the environment be a vector of \emph{values} and not of
value-families. By studying carefully the case for instantiating closures
(where the rubber meets the road for variables), I think it becomes clear that
this is the right way.

To interpret a variable, we just project from the environment and ignore the
restriction. I think the way that we had been thinking of doing it would result
in the restriction from inside the closure infecting the argument.

\bigskip


Colors: \FmtTm{terms}, \FmtFam{value families}, \FmtVal{values},
\FmtRst{restrictions}. I am writing $\Rst{\phi}{F}$ to mean the reindexing of a
family by a restriction.

\begin{align*}
  \Eval{
    \TLam{M}
  }{\rho}
  &=
  \Fam{\phi}{
    \VLam{
      \VClo{M}{\rho}{\phi}
    }
  }
  \\
  \Eval{
    \TPi{A}{B}
  }{\rho}
  &=
  \Fam{\phi}{
    \VPi{
      \Rst{\phi}{\Eval{A}{\rho}}
    }{
      \VClo{B}{\rho}{\phi}
    }
  }
  \\
  \Eval{
    \TApp{M}{N}
  }{\rho}
  &=
  \SemApp{
    \Eval{M}{\rho}
  }{
    \Eval{N}{\rho}
  }
  \\
  \Eval{
    \TVar{i}
  }{\rho}
  &=
  \Fam{\_}{
    \rho_i
  }
\end{align*}

\[
  \SemApp{F}{G}
  =
  \Fam{\phi}{
    \begin{cases}
      \Cond{
        \FamTest{F}{\phi}
        \equiv
        \VLam{
          \VClo{M}{\rho}{\psi}
        }
      }{
        \FamTest{
          \Eval{M}{\rho, \FamTest{G}{\phi}}
        }{
          \psi
        }
      }
      \\
      \Cond{
        \FamTest{F}{\phi}
        \equiv
        \VUp{C}{R},
        \FamTest{C}{\RstId}\equiv \VPi{A}{\VClo{B}{\rho}{\psi}}
      }{
        \VUp{
          \Rst{\psi}{\Eval{B}{\rho,\FamTest{G}{\phi}}}
        }{
          \VApp{R}{
            \Rst{\phi}{G}
          }
        }
      }
      \\
      \Cond{
        \FamTest{F}{\phi}
        \equiv
        \Hole{coe}
      }{
        \Hole{coe}
      }
      \\
      \Cond{
        \FamTest{F}{\phi}
        \equiv
        \VHCom{r}{r'}{C}{M}{
          \Vec{
            \VFace{\xi_i}{
              \VAbs{\alpha_i}{N_i}
            }
          }
        },
        \FamTest{C}{\RstId}\equiv
        \VPi{A}{\VClo{B}{\rho}{\psi}}
      }{
        \Fresh{\beta}{
          \SemHCom{r}{r'}{
            \Rst{\psi}{\Eval{B}{\rho,\FamTest{G}{\phi}}}
          }{
            \SemApp{M}{\Rst{\phi}{G}}
          }{
            \Vec{
              \VFace{\xi_i}{
                \VAbs{\beta}{
                  \SemApp{
                    \Act{
                      \Swap{\alpha_i}{\beta}
                    }{N_i}
                  }{
                    \Rst{\phi}{G}
                  }
                }
              }
            }
          }
        }
      }
    \end{cases}
  }
\]

\[
  \SemHCom{r}{r'}{C}{M}{
    \Vec{
      \VFace{\xi_i}{\VAbs{\alpha_i}{N_i}}
    }
  }
  =
  \FmtVal{
    \begin{cases}
      \Cond{
        \FamTest{r}{\RstId}=\FamTest{r'}{\RstId}
      }{
        \FamTest{M}{\RstId}
      }
      \\
      \Cond{
        \exists_{\textit{min}}k.\models\FamTest{\xi_k}{\RstId}
      }{
        \FamTest{N_k}{
          \RstEquate{\alpha_k}{\FamTest{r'}{\RstId}}
        }
      }
      \\
      \Cond{
        \FamTest{C}{\RstId}
        \equiv
        \VPi{A}{B}
      }{
        \VHCom{r}{r'}{C}{M}{
          \Vec{
            \VFace{\xi_i}{\VAbs{\alpha_i}{N_i}}
          }
        }
      }
      \\
      \Cond{
        \FamTest{C}{\RstId}\equiv\VBool
      }{
        \FamTest{M}{\RstId}
      }
    \end{cases}
  }
\]

\end{document}
