\documentclass{article}
\usepackage[colorlinks]{hyperref}
\usepackage{natbib}

\usepackage{fontawesome}
\usepackage{dingbat}

\usepackage{amssymb}


\usepackage[tt=false]{libertine}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{mathpartir}
\usepackage[dvipsnames]{xcolor}
\usepackage{fullpage}
\usepackage{manfnt}

\usepackage{mathtools}

\DeclarePairedDelimiter\Parens{\lparen}{\rparen}
\DeclarePairedDelimiter\Angles{\langle}{\rangle}
\DeclarePairedDelimiter\Squares{[}{]}

\DeclarePairedDelimiter\Braces{\lbrace}{\rbrace}
\DeclarePairedDelimiter\Pipes{\lvert}{\rvert}

\newcommand\Len[1]{\Pipes*{#1}}

\newtheorem{remark}{Remark}



\usepackage{stmaryrd}

\title{Cartesian Cubical Type Theory:\\ Reduction-Free Semantics and
  Definitional Equivalence} \author{Jon Sterling}

\newcommand\FmtKwd[1]{\mathsf{#1}}

\newcommand\DeclBox[1]{\framebox{$\displaystyle{}#1$}}
\newcommand\FmtThin[1]{{\color{ProcessBlue}#1}}
\newcommand\XThin[3]{{#2}\rightarrowtriangle_{#1}{#3}}

\newcommand\Thin[2]{{#1}\rightarrowtriangle{#2}}
\newcommand\IsThin[3]{\FmtThin{#1}:\Thin{#2}{#3}}
\newcommand\IsXThin[4]{\FmtThin{#1}:\XThin{#2}{#3}{#4}}

\newcommand\ThinId{\mathsf{id}}
\newcommand\ThinKeep[1]{\mbox{\leftthumbsdown}\!\!\rangle\!{#1}\!\langle\!\!\mbox{\rightthumbsdown}}
\newcommand\ThinSkip[1]{{#1}.\mbox{\faTrashO}}
\newcommand\ThinRep[2]{{#1}.\Squares*{{\normalcolor{}#2}}}

\usepackage{xinttools}

\newcommand\FormatList[3]{%
  \xintFor ##1 in {#3} \do{%
    #1{##1}%
    \xintifForLast{}{#2}
  }
}



\newcommand\THIN{\mathbf{Thin}}
\newcommand\OpCat[1]{{#1}^{\mathsf{op}}}
\newcommand\SET{\mathbf{Set}}

\newcommand\Interval{\FmtKwd{dim}}
\newcommand\Bool{\FmtKwd{bool}}
\newcommand\Atom[1]{{\boldsymbol\alpha}_{#1}}
\newcommand\Var[1]{\mathsf{v}_{#1}}

\newcommand\SortChk{\FmtKwd{chk}}
\newcommand\SortInf{\FmtKwd{inf}}

\newcommand\SortCofib{\FmtKwd{cofig}}
\newcommand\SortSys{\FmtKwd{sys}}


\newcommand\Tm[3]{{#1}\mid{#2}\vdash{#3}}
\newcommand\FmtTm[1]{{\color{Violet}#1}}
\newcommand\IsTm[4]{{#1}\mid{#2}\vdash\FmtTm{#3}:{#4}}
\newcommand\IsChk[3]{\IsTm{#1}{#2}{#3}{\SortChk}}
\newcommand\IsInf[3]{\IsTm{#1}{#2}{#3}{\SortInf}}

\newcommand\TExp[2]{
  \FmtTm{
    \Parens*{
      \FmtKwd{#1}\
      \FormatList{}{\ }{#2}
    }
  }
}


\newcommand\FmtVal[1]{{\color{Red}{#1}}}

\newcommand\VExp[2]{
  \FmtVal{
    \Parens*{
      \FmtKwd{#1}\
      \FormatList{}{\ }{#2}
    }
  }
}


\newcommand\EvalClo[2]{\FmtVal{#1}\Downarrow\FmtVal{#2}}
\newcommand\Eval[5]{\FmtThin{#2}*\FmtVal{#3}\vDash\FmtTm{#4}\mathrel{\Downarrow_{\FmtThin{#1}}}\FmtVal{#5}}
\newcommand\Apply[3]{\FmtVal{#1}\mathrel{@}\FmtVal{#2}\Downarrow\FmtVal{#3}}
\newcommand\InstClo[3]{\FmtVal{#1}\bullet\FmtVal{#2}\Downarrow\FmtVal{#3}}
\newcommand\ThinVal[2]{\widehat{\FmtThin{#1}}\Parens*{\FmtVal{#2}}}
\newcommand\ThinTmAtom[2]{\widehat{\FmtThin{#1}}_{\Atom{}}\Parens*{\FmtTm{#2}}}
\newcommand\ThinTmVar[2]{\widehat{\FmtThin{#1}}_{\Var{}}\Parens*{\FmtTm{#2}}}
\newcommand\Car[2]{\FmtVal{#1}\ \mathbf{car}\Downarrow\FmtVal{#2}}
\newcommand\Cdr[2]{\FmtVal{#1}\ \mathbf{cdr}\Downarrow\FmtVal{#2}}


\begin{document}
\maketitle

The purpose of these notes is to develop a reduction-free semantics
and algorithmic theory of definitional equivalence for cartesian
cubical type theory which is as efficient and carefully organized as
possible: in particular, we arrange to calculate all substitutions and
renamings lazily using environments and closures. Our definition of
both the syntactic and the semantic domain is strongly scoped, which
makes it easier to verify the that we have correctly resolved the
contradiction between the name and the location of a bound variable.

In these notes, we use colors to distinguish objects of different
(meta) sorts from each other, in order to avoid getting lost in a
hurricane of superscripts. As such, $\FmtTm{M}$ and $\FmtVal{M}$ are
to be understood as distinct schematic variables. Some of the ideas
for dealing with evaluation under dimension binders come from joint
work with Favonia and Daniel Gratzer and Carlo Angiuli; the idea of
generalized thinnings comes from Conor McBride (as far as I am aware).

\section{Defunctionalized NbE}

We develop evaluation and quotation judgments for Cartesian Cubical
Type Theory inspired by normalization by evaluation (NbE), in its
\emph{defunctionalized} variant. Often NbE is presented using domain
models and binding is represented using meta-level functions, and
evaluation and quotation are intertwined. My perspective is that the
correct theoretical development of a concept should mirror a practical
implementation; therefore, we choose to suspend in syntax the
structure of the NbE algorithm, using closures and shifts in the
semantic domain. In this style of NbE, the evaluation function is
called from the quotation function, but not vice versa.

The state of the art in the science of normalization by evaluation is found in
Andreas Abel's habilitation thesis~\citep{abel:2013}; other relevant sources are included in the bibliography of these notes.

\paragraph{Why NbE?}

The old practice of regarding computation as a kind of rewriting
system does not scale cleanly to calculation with
indeterminates. Inefficiency is not the only nail in the coffin of the
old heroic attempts to unleash open computation by attacking a term
with rewriting rules; it is typical of \emph{rewriting-theory
  dogmato-revisionism} to account for only one half of the dialectic
of open term behavior: indeed, any account of computation for open
terms of negative type must explain not only reduction, but also
expansion.

\textbf{I want to clarify that my main goal is not to acquire a normalization
function.} I am trying to decide definitional equivalence, and the simplest way
to do this algorithmically follows the structure of NbE very closely
(regardless of whether it is instantiated to yield a normalization function).


\section{Thinnings}

$X$-Thinnings are a defunctionalized representation of substitutions
which capture the idea of deleting some variables from within a
context, or possibly replacing them with an element of the family
$X:\SET^{\mathbb{N}}$. When $X$ is the empty family, these correspond
to the \emph{order-preserving embeddings} of Chapman.
%
We choose a representation of thinnings which lends itself to
efficient calculation, but is not canonical; therefore, any operation
on thinnings must be proved to be respect the algebraic laws of
thinnings in order to be well-defined.
\begin{mathparpagebreakable}
  \DeclBox{
    \IsXThin{f}{X}{n}{m}
  }
  \\
  \inferrule{
  }{
    \IsXThin{\ThinId}{X}{n}{n}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{n}{m}
  }{
    \IsXThin{\ThinKeep{f}}{X}{n+1}{m+1}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{n}{m}
  }{
    \IsXThin{\ThinSkip{f}}{X}{n+1}{m}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{n}{m}
    \\
    a:X_n
  }{
    \IsXThin{\ThinRep{f}{a}}{X}{n}{m+1}
  }
\end{mathparpagebreakable}

We will write $\THIN$ for the category of $\varnothing$-thinnings
induced by the above. To simplify notation, we write $\Thin{n}{m}$ for
$\XThin{\varnothing}{n}{m}$.

\section{Terms}

\newcommand\TSubstA[3]{
  \TExp{subst_{\Atom{}}}{
    \FmtThin{#1}%
    \mathbin{{\color{gray}*}}%
    \FmtThin{#2},
    \FmtThin{#3}
  }
}

\newcommand\TThinV[2]{
  \TExp{thin_{\Var{}}}{
    \FmtThin{#1},
    #2
  }
}


In our term language, we distinguish between \emph{atoms} and
\emph{variables}, and their respective binders. Variable binders are
given meaning through substitution, whereas atom binders are subject
to open evaluation. Most binders are variable binders; the only atom
binder in our language comes from $\FmtKwd{coe}$.


\begin{remark}
  This is a matter of some subtlety in the context of
  \emph{normalization by evaluation} in which the evaluation and
  quotation phases of computation are distinguished: while we do not
  evaluate underneath a variable binder, during the quotation phase we
  \emph{do} instantiate such a variable binder with a semantic
  indeterminate or generic element: so, even though we end up
  transforming the interior of the binder, this is still done through
  substitution. In contrast, we do evaluate underneath atom binders.
\end{remark}

\begin{remark}
  Note that the atom/variable distinction does not align with the
  distinction of dimension variables from other variables. Dimensions
  in our formal language are treated the same as other terms, and some
  dimensions are bound as atoms (such as in $\FmtKwd{coe}$) and others
  are bound as variables (as in path types and path
  abstractions). Note that we also treat path abstraction and
  functional abstraction uniformly using $\FmtKwd{lam}$.
\end{remark}


Terms are classified by sorts $\tau\in\Braces*{\SortChk,\SortInf}$; we
will write the judgment $\IsTm{n}{l}{M}{\tau}$ to mean that
$\FmtTm{M}$ is a term of sort $\tau$ with $n$ atoms and $l$
variables. In the term language, both atoms and variables are managed
using De Bruijn indices. An illustrative fragment of the syntax is
presented below.

\begin{mathparpagebreakable}
  \DeclBox{
    \IsTm{n}{l}{M}{\tau}
  }
  \\
  \and
  \inferrule[TmAtom]{
    i<n
  }{
    \IsInf{n}{l}{\Atom{i}}
  }
  \and
  \inferrule[TmVar]{
    i<l
  }{
    \IsInf{n}{l}{\Var{i}}
  }
  \and
  \inferrule[TmPi]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l+1}{B}
  }{
    \IsChk{n}{l}{
      \TExp{\Pi}{A,B}
    }
  }
  \and
  \inferrule[TmSg]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l+1}{B}
  }{
    \IsChk{n}{l}{
      \TExp{\Sigma}{A,B}
    }
  }
  \and
  \inferrule[TmEq]{
    \IsChk{n}{l+1}{A}
    \\
    \IsChk{n}{l}{M}
    \\
    \IsChk{n}{l}{N}
  }{
    \IsChk{n}{l}{
      \TExp{eq}{A,M,N}
    }
  }
  \and
  \inferrule[TmLam]{
    \IsChk{n}{l+1}{M}
  }{
    \IsChk{n}{l}{\TExp{\lambda}{M}}
  }
  \and
  \inferrule[TmCons]{
    \IsChk{n}{l}{M}
    \\
    \IsChk{n}{l}{N}
  }{
    \IsChk{n}{l}{\TExp{cons}{M,N}}
  }
  \and
  \inferrule[TmCar]{
    \IsInf{n}{l}{R}
  }{
    \IsInf{n}{l}{\TExp{car}{R}}
  }
  \and
  \inferrule[TmCdr]{
    \IsInf{n}{l}{R}
  }{
    \IsInf{n}{l}{\TExp{cdr}{R}}
  }
  \and
  \inferrule[TmDim0]{
  }{
    \IsChk{n}{l}{0}
  }
  \and
  \inferrule[TmDim1]{
  }{
    \IsChk{n}{l}{1}
  }
  \and
  \inferrule[TmUp]{
    \IsInf{n}{l}{R}
  }{
    \IsChk{n}{l}{\TExp{\uparrow}{R}}
  }
  \and
  \inferrule[TmApp]{
    \IsInf{n}{l}{R}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{\TExp{@}{R,M}}
  }
  \and
  \inferrule[TmDown]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{\TExp{\downarrow}{A,M}}
  }
  \and
  \inferrule[TmCoe]{
    \IsChk{n}{l}{I}
    \\
    \IsChk{n}{l}{J}
    \\
    \IsChk{n+1}{l}{A}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{
      \TExp{coe}{
        I,
        J,
        A,
        M
      }
    }
  }
  \and
  \inferrule[TmSys]{
    \overline{
      \IsChk{n}{l}{I_i}
    }
    \\
    \overline{
      \IsChk{n}{l}{J_i}
    }
    \\
    \overline{
      \IsChk{n}{l}{M_i}
    }
  }{
    \IsTm{n}{l}{
      \Squares*{
        \overline{I_i=J_i\mapsto M_i}
      }
    }{\SortSys}
  }
  \and
  \inferrule[TmExtend]{
    \IsChk{n}{l}{A}
    \\
    \IsTm{n}{l}{S}{\SortSys}
  }{
    \IsChk{n}{l}{
      \TExp{ext}{
        A,
        S
      }
    }
  }
  \and
  \inferrule[TmHCom]{
    \IsChk{n}{l}{I}
    \\
    \IsChk{n}{l}{J}
    \\
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l}{M}
    \\
    \IsTm{n}{l}{S}{\SortSys}
  }{
    \IsInf{n}{l}{
      \TExp{hcom}{
        I,
        J,
        A,
        M,
        S
      }
    }
  }
  \and
  \inferrule[TmSubstAtom]{
    \IsTm{m}{l}{M}{\tau}
    \\
    \IsXThin{f}{\Parens*{\Tm{\square}{k}{\SortInf}}}{n}{m}
    \\
    \IsThin{g}{l}{k}
  }{
    \IsTm{n}{l}{
      \TSubstA{g}{f}{M}
    }{\tau}
  }
  \and
  \inferrule[TmThinVar]{
    \IsTm{m}{k}{M}{\tau}
    \\
    \IsThin{f}{l}{k}
  }{
    \IsTm{n}{l}{
      \TThinV{f}{M}
    }{\tau}
  }
\end{mathparpagebreakable}


\newcommand\PushSubstA[4]{\Squares*{\FmtThin{#1}*\FmtThin{#2}}*\FmtTm{#3}\leadsto\FmtTm{#4}}
\newcommand\PushThinV[3]{\FmtThin{#1}*\FmtTm{#2}\leadsto\FmtTm{#3}}

\subsection{Explicit Substitutions}

In the term language, we have explicit substitutions of atoms
$\TSubstA{g}{f}{M}$ and thinnings of variables $\TThinV{f}{M}$; these
can be cheaply \emph{pushed} inward in the following way:

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgSubstA]{
      \IsTm{m}{l}{M}{\tau}
      \\
      \IsXThin{f}{\Parens*{\Tm{\square}{l'}{\SortInf}}}{n}{m}
      \\
      \IsThin{g}{l}{l'}
      \\
      \IsTm{n}{l}{N}{\tau}
    }{
      \DeclBox{
        \PushSubstA{g^+}{f^+}{M^+}{N^-}
      }
    }
  }
  \\
  \inferrule[SubstAId]{}{
    \PushSubstA{g}{\ThinId}{M}{M}
  }
  \and
  \inferrule[SubstASubstAtom]{
    \PushSubstA{g'}{f'}{M}{M'}
    \\
    \PushSubstA{g}{f}{M'}{M''}
  }{
    \PushSubstA{g}{f}{
      \TSubstA{g'}{f'}{M}
    }{
      M''
    }
  }
  \and
  \inferrule[SubstAThinV]{
    \PushThinV{h}{M}{M'}
    \\
    \PushSubstA{g}{f}{M'}{M''}
  }{
    \PushSubstA{g}{f}{\TThinV{h}{M}}{M''}
  }
  \and
  \inferrule[SubstAAtom]{
    \PushSubstA{\ThinId}{\ThinId}{f_{\Atom{}}\Parens{i}}{M}
  }{
    \PushSubstA{g}{f}{\Atom{i}}{
      \ThinTmVar{g}{M}
    }
  }
  \and
  \inferrule[SubstAVar]{}{
    \PushSubstA{g}{f}{\Var{i}}{g_{\Var{\square}}\Parens{i}}
  }
  \and
  \inferrule[SubstALam]{}{
    \PushSubstA{g}{f}{
      \TExp{\lambda}{M}
    }{
      \TExp{\lambda}{
        \TSubstA{\ThinSkip{g}}{f}{M}
      }
    }
  }
  \\
  \inferrule[SubstACoe]{}{
    \PushSubstA{g}{f}{
      \TExp{coe}{
        I,
        J,
        A,
        M
      }
    }{
      \TExp{coe}{
        \TSubstA{g}{f}{I},
        \TSubstA{g}{f}{J},
        \TSubstA{g}{\ThinSkip{f}}{A},
        \TSubstA{g}{f}{M}
      }
    }
  }
\end{mathparpagebreakable}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgThinV]{
      \IsTm{n}{k}{M}{\tau}
      \\
      \IsThin{f}{l}{k}
      \\
      \IsTm{n}{l}{N}{\tau}
    }{
      \DeclBox{
        \PushThinV{f^+}{M^+}{N^-}
      }
    }
  }
  \\
  \inferrule[ThinVId]{}{
    \PushThinV{\ThinId}{M}{M}
  }
  \and
  \inferrule[ThinVSubstA]{
    \PushSubstA{g}{f}{M}{M'}
    \\
    \PushThinV{h}{M'}{M''}
  }{
    \PushThinV{h}{
      \TSubstA{g}{f}{M}
    }{M''}
  }
  \and
  \inferrule[ThinVThinV]{
    \PushThinV{f}{M}{M'}
    \\
    \PushThinV{g}{M'}{M''}
  }{
    \PushThinV{g}{
      \TThinV{f}{M}
    }{M''}
  }
  \and
  \inferrule[ThinVLam]{}{
    \PushThinV{f}{
      \TExp{\lambda}{M}
    }{
      \TExp{\lambda}{
        \TThinV{\ThinSkip{f}}{M}
      }
    }
  }
\end{mathparpagebreakable}

\section{Semantic Domain}

The semantic domain of our language is really another syntax, in which
variables are replaced by semantic indeterminates (represented as De
Bruijn levels), and atoms remain represented as De Bruijn indices. The
semantic domain captures the weak-head normal forms of our language;
because we intend to develop a substitution-free evaluation semantics using
environments, we must naturally employ a notion of \emph{closure}.

\newcommand\SortCan{\FmtKwd{can}}
\newcommand\SortNeu{\FmtKwd{neu}}
\newcommand\SortClo{\FmtKwd{clo}}
\newcommand\SortBClo{\FmtKwd{bclo}}
\newcommand\SortEnv[1]{\FmtKwd{env}_{#1}}
\newcommand\IsVal[3]{{#1}\Vdash\FmtVal{#2}:{#3}}
\newcommand\Val[2]{{#1}\Vdash{#2}}

\newcommand\Clo[4]{
  \Squares*{
    \FmtThin{#1}%
    \mathbin{\color{gray}*}%
    \Angles*{
      \FmtTm{#4}
      \mathbin{\color{gray}\triangleleft}%
      \FmtThin{#2}
      \mathbin{\color{gray}*}%
      \FmtVal{#3}
    }
  }
}

\newcommand\BClo[4]{
  \Squares*{
    \FmtThin{#1}%
    \mathbin{\color{gray}*}%
    \Angles*{
      \FmtTm{#4}
      \mathbin{\color{gray}\triangleleft^+}%
      \FmtThin{#2}
      \mathbin{\color{gray}*}%
      \FmtVal{#3}
    }
  }
}


Values are classified by sorts
$\tau\in\Braces*{\SortCan,\SortNeu,\SortEnv{l},\SortClo,\SortBClo}$; for
such a sort $\tau$, we will write $\IsVal{n}{M}{\tau}$ to mean that
$\FmtVal{M}$ is a value of sort $\tau$ with $n$ atoms. We no longer
track the number of variables, because these are replaced by
indeterminates in the form of De Bruijn levels (which have an absolute
reference).

\begin{mathparpagebreakable}
  \DeclBox{
    \IsVal{n}{M}{\tau}
  }
  \\
  \inferrule[ValAtom]{
    i<n
  }{
    \IsVal{n}{\Atom{i}}{\SortCan}
  }
  \and
  \inferrule[ValGen]{
  }{
    \IsVal{n}{\Var{l}}{\SortNeu}
  }
  \and
  \inferrule[ValUp]{
    \IsVal{n}{A}{\SortCan}
    \\
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{
      \VExp{\uparrow}{A,R}
    }{\SortCan}
  }
  \and
  \inferrule[ValClo]{
    \IsThin{g}{o}{n}
    \\
    \IsThin{f}{n}{m}
    \\
    \IsVal{m}{\rho}{\SortEnv{l}}
    \\
    \IsTm{n}{l}{M}{\SortChk}
  }{
    \IsVal{o}{
      \Clo{g}{f}{\rho}{M}
    }{\SortClo}
  }
  \and
  \inferrule[ValBClo]{
    \IsThin{g}{o}{n}
    \\
    \IsThin{f}{n}{m}
    \\
    \IsVal{m}{\rho}{\SortEnv{l}}
    \\
    \IsTm{n}{l+1}{M}{\SortChk}
  }{
    \IsVal{o}{
      \BClo{g}{f}{\rho}{M}
    }{\SortBClo}
  }
  \and
  \inferrule[ValEnv]{
    \forall{i<l}.\ \IsVal{n}{M_i}{\SortCan}
  }{
    \IsVal{n}{\Squares{M_i}_{i<l}}{\SortEnv{l}}
  }
  \\
  \inferrule[ValPi]{
    \IsVal{n}{A}{\SortClo}
    \\
    \IsVal{n}{A}{\SortBClo}
  }{
    \IsVal{n}{
      \VExp{\Pi}{A,B}
    }{\SortCan}
  }
  \and
  \inferrule[ValLam]{
    \IsVal{n}{M}{\SortClo}
  }{
    \IsVal{n}{\VExp{\lambda}{M}}{\SortCan}
  }
  \and
  \inferrule[ValApp]{
    \IsVal{n}{R}{\SortNeu}
    \\
    \IsVal{n}{M}{\SortCan}
  }{
    \IsVal{n}{\VExp{@}{R,M}}{\SortNeu}
  }
  \and
  \inferrule[ValCons]{
    \IsVal{n}{M}{\SortClo}
    \\
    \IsVal{n}{N}{\SortClo}
  }{
    \IsVal{n}{\VExp{cons}{M,N}}{\SortCan}
  }
  \and
  \inferrule[ValCar]{
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{\VExp{car}{R}}{\SortNeu}
  }
  \and
  \inferrule[ValCdr]{
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{\VExp{cdr}{R}}{\SortNeu}
  }
  \and
  \inferrule[ValCoe]{
    \IsVal{n}{I}{\SortCan}
    \\
    \IsVal{n}{J}{\SortCan}
    \\
    \IsVal{n+1}{A}{\SortCan}
    \\
    \IsVal{n}{M}{\SortCan}
  }{
    \IsVal{n}{
      \VExp{coe}{I,J,A,M}
    }{\SortCan}
  }
\end{mathparpagebreakable}


The syntax of values can be reindexed contravariantly along
thinnings $\IsThin{f}{m}{n}$; the
reindexing action is renaming.

\begin{remark}[Reification and reflection]

  In modern NbE, eta expansion is divided into two phases called
  ``reification'' and ``reflection'', which occur entirely at the level of the
  semantic domain. Reflection $\uparrow$ embeds the neutral values into the
  canonical values, and reification $\downarrow$ embeds the canonical values
  into the normal values.
%
  In this presentation so far, we have not yet phrased things in terms of
  reification and ``normal values''; I will change this shortly.

\end{remark}


\begin{remark}[Extension with singleton and extension types]

  Reflection of neutral values into canonical values is present in the semantic
  domain as a ``free'' constructor, rather than as an operation. This is
  because reflection is calculated lazily.

  To extend with constructs like singleton-type (and extension types), it is
  necessary to impose an equational law on reflection: basically, reflecting a
  neutral of singleton type should project out a canonical value from the
  singleton type.

  There are a couple of ways to enact this equation. One is to change
  reflection into a ``smart operation''; another way, however, would be to add
  cases to each of the rules that match suspended reflections, and perform the
  expansion in-line. It's not yet clear to me which style is best.

\end{remark}


\section{Evaluation}


At a high level, evaluation takes terms to values; at a finer-grained
level, however, we will evaluate with respect to a thinning
$\FmtThin{g}$ and an environment $\FmtVal{\rho}$ together with a
thinning $\FmtThin{f}$; this allows us to avoid actually executing
thinnings and substitutions until the last moment possible. In fact,
the preceding sentence can be rephrased as construing evaluation as a
relation $\EvalClo{M_\SortClo}{M_\SortCan}$ where
$\IsVal{n}{M_\SortClo}{\SortClo}$ and
$\IsVal{n}{M_\SortCan}{\SortCan}$.

We will write $\Eval{g}{f}{\rho}{M}{M}$ as a notation for
$\EvalClo{\Clo{g}{f}{\rho}{M}}{M}$, when it is well-formed:


\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgEval]{
      \IsThin{g}{o}{n}
      \\
      \IsThin{f}{n}{m}
      \\
      \IsVal{m}{\rho}{\SortEnv{l}}
      \\
      \IsTm{n}{l}{M}{\tau}
      \\
      \IsVal{o}{M}{\SortCan}
    }{
      \DeclBox{
        \Eval{g^+}{f^+}{\rho^+}{M^+}{M^-}
      }
    }
  }
  \\
  \inferrule[EvalSubstA]{
    \PushSubstA{j}{h}{M}{M'}
    \\
    \Eval{g}{f}{\rho}{M'}{M'}
  }{
    \Eval{g}{f}{\rho}{
      \TSubstA{j}{h}{M}
    }{M'}
  }
  \and
  \inferrule[EvalThinV]{
    \PushThinV{h}{M}{M'}
    \\
    \Eval{g}{f}{\rho}{M'}{M'}
  }{
    \Eval{g}{f}{\rho}{
      \TThinV{h}{M}
    }{M'}
  }
  \and
  \inferrule[EvalAtom]{}{
    \Eval{g}{f}{\rho}{\Atom{i}}{
      \ThinVal{g}{\Atom{i}}
    }
  }
  \and
  \inferrule[EvalVar]{}{
    \Eval{g}{f}{\rho}{\Var{l}}{
      \ThinVal{
        g\circ{}f
      }{\rho_l}
    }
  }
  \and
  \inferrule[EvalPi]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\Pi}{A,B}
    }{
      \VExp{\Pi}{
        \Clo{g}{f}{\rho}{A},
        \BClo{g}{f}{\rho}{B}
      }
    }
  }
  \and
  \inferrule[EvalSg]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\Sigma}{A,B}
    }{
      \VExp{\Sigma}{
        \Clo{g}{f}{\rho}{A},
        \BClo{g}{f}{\rho}{B}
      }
    }
  }
  \and
  \inferrule[EvalPath]{}{
    \Eval{g}{f}{\rho}{
      \TExp{path}{A,M,N}
    }{
      \VExp{path}{
        \BClo{g}{f}{\rho}{A},
        \Clo{g}{f}{\rho}{M},
        \Clo{g}{f}{\rho}{N}
      }
    }
  }
  \and
  \inferrule[EvalLam]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\lambda}{M}
    }{
      \VExp{\lambda}{
        \BClo{g}{f}{\rho}{M}
      }
    }
  }
  \and
  \and
  \inferrule[EvalUp]{
    \Eval{g}{f}{\rho}{R}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{\uparrow}{R}
    }{
      M
    }
  }
  \and
  \inferrule[EvalDown]{
    \Eval{g}{f}{\rho}{M}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{\downarrow}{A,M}
    }{M}
  }
  \and
  \inferrule[EvalCoe]{
    \Eval{g}{f}{\rho}{I}{I}
    \\
    \Eval{g}{f}{\rho}{J}{J}
    \\
    \Eval{\ThinKeep{g}}{\ThinSkip{f}}{\rho}{A}{A}
    \\
    \Eval{g}{f}{\rho}{M}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{coe}{I,J,A,M}
    }{
      \VExp{coe}{
        I,
        J,
        A,
        M
      }
    }
  }
  \and
  \inferrule[EvalApp]{
    \Eval{g}{f}{\rho}{R}{M_{\mathsf{fun}}}
    \\
    \Eval{g}{f}{\rho}{M}{M_{\mathsf{arg}}}
    \\
    \Apply{M_{\mathsf{fun}}}{M_{\mathsf{arg}}}{N}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{@}{
        R,
        M
      }
    }{
      N
    }
  }
  \and
  \inferrule[EvalCar]{
    \Eval{g}{f}{\rho}{R}{M}
    \\
    \Car{M}{N}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{car}{R}
    }{N}
  }
  \and
  \inferrule[EvalCdr]{
    \Eval{g}{f}{\rho}{R}{M}
    \\
    \Cdr{M}{N}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{cdr}{R}
    }{N}
  }
\end{mathparpagebreakable}


\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgInst]{
      \IsVal{n}{M}{\SortBClo}
      \\
      \IsVal{n}{N}{\SortCan}
      \\
      \IsVal{n}{O}{\SortCan}
    }{
      \DeclBox{\InstClo{M^+}{N^+}{O^-}}
    }
  }
  \and
  \inferrule[InstBClo]{
    \Eval{g}{f}{\Squares*{N,\rho}}{M}{O}
  }{
    \InstClo{
      \BClo{g}{f}{\rho}{M}
    }{N}{O}
  }
\end{mathparpagebreakable}


\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgApply]{
      \IsVal{n}{M}{\SortCan}
      \\
      \IsVal{n}{N}{\SortCan}
      \\
      \IsVal{n}{O}{\SortCan}
    }{
      \DeclBox{\Apply{M^+}{N^+}{O^-}}
    }
  }
  \\
  \inferrule[ApplyLam]{
    \InstClo{M}{N}{O}
  }{
    \Apply{\VExp{\lambda}{M}}{N}{O}
  }
  \and
  \inferrule[ApplyUpPi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortClo}{N}{B_\SortCan}
  }{
    \Apply{
      \VExp{\uparrow}{
        \VExp{\Pi}{A_\SortClo,B_\SortBClo},
        R
      }
    }{N}{
      \VExp{\uparrow}{
        B_\SortCan,
        \VExp{@}{
          R,
          N
        }
      }
    }
  }
  \and
  \inferrule[ApplyUpPathConst]{
    \EvalClo{M_\SortClo^\epsilon}{M_\SortCan^\epsilon}
  }{
    \Apply{
      \VExp{\uparrow}{
        \VExp{path}{A,M_\SortClo^0,M_\SortClo^1},
        R
      }
    }{\epsilon}{M_\SortCan^\epsilon}
  }
  \and
  \inferrule[ApplyUpPathNeu]{
    \InstClo{A_\SortBClo}{
      \VExp{\uparrow}{
        \Interval,
        S
      }
    }{A_\SortCan}
  }{
    \Apply{
      \VExp{\uparrow}{
        \VExp{path}{A_\SortBClo,M_\SortClo^0,M_\SortClo^1},
        R
      }
    }{
      \VExp{\uparrow}{
        \Interval,
        S
      }
    }{
      \VExp{\uparrow}{
        A_\SortCan,
        \VExp{@}{
          R,
          \VExp{\uparrow}{
            \Interval,
            S
          }
        }
      }
    }
  }
  \and
  \inferrule[ApplyCoePi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortBClo}{
      \VExp{coe}{
        \ThinVal{\ThinSkip{\ThinId}}{J},
        \Atom{0},
        \ThinVal{
          \ThinKeep{\ThinSkip{\ThinId}}
        }{A_\SortCan},
        \ThinVal{\ThinSkip{\ThinId}}{N}
      }
    }{
      B_\SortCan{}
    }
    \\
    \Apply{M}{
      \VExp{coe}{
        J,
        I,
        A_\SortCan,
        N
      }
    }{O}
  }{
    \Apply{
      \VExp{coe}{
        I,
        J,
        \VExp{\Pi}{A_\SortClo,B_\SortBClo},
        M
      }
    }{N}{
      \VExp{coe}{
        I,
        J,
        B_\SortCan,
        O
      }
    }
  }
\end{mathparpagebreakable}

Observe how in \textsc{ApplyCoePi}, we used in an essential way the
fact that the dimension binder of $\FmtKwd{coe}$ abstracts an
\emph{atom} rather than a \emph{variable}; in the semantic domain,
this means that we may name this dimension using an atom of the $0$th
De Bruijn index. This is essential: if we had bound a variable rather
than an atom, it would be impossible from this point of view of the
application judgment to know the De Bruijn level of the bound
dimension.

The cost of this solution to the problem of evaluating under binders
is that we must be careful to apply thinnings in all the right
places. It is easy to verify that the semantic term is well-formed
using the strongly-scoepd term formation rules given; moreover, the
thinnings will generally be inexpensive, since they tend to pile up on
closures.

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgCar]{
      \IsVal{n}{M}{\SortCan}
      \\
      \IsVal{n}{N}{\SortCan}
    }{
      \DeclBox{
        \Car{M^+}{N^-}
      }
    }
  }
  \\
  \inferrule[CarCons]{}{
    \Car{
      \VExp{cons}{M,N}
    }{M}
  }
  \and
  \inferrule[CarUpSg]{
    \EvalClo{A_\SortClo}{A_\SortCan}
  }{
    \Car{
      \VExp{\uparrow}{
        \VExp{\Sigma}{A_\SortClo,B_\SortBClo},
        R
      }
    }{
      \VExp{\uparrow}{
        A_\SortCan,
        \VExp{car}{R}
      }
    }
  }
  \and
  \inferrule[CarCoeSg]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \Car{M}{N}
  }{
    \Car{
      \VExp{coe}{
        I,
        J,
        \VExp{\Sigma}{
          A_\SortClo,
          B_\SortBClo%
        },
        M
      }
    }{
      \VExp{coe}{
        I,
        J,
        A_\SortCan,
        N
      }
    }
  }
\end{mathparpagebreakable}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgCdr]{
      \IsVal{n}{M}{\SortCan}
      \\
      \IsVal{n}{N}{\SortCan}
    }{
      \DeclBox{
        \Cdr{M^+}{N^-}
      }
    }
  }
  \\
  \inferrule[CdrCons]{}{
    \Cdr{
      \VExp{cons}{M,N}
    }{N}
  }
  \and
  \inferrule[CdrUpSg]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortBClo}{
      \VExp{\uparrow}{
        A_\SortCan,
        \VExp{car}{R}
      }
    }{B_\SortCan}
  }{
    \Cdr{
      \VExp{\uparrow}{
        \VExp{\Sigma}{A_\SortClo,B_\SortBClo},
        R
      }
    }{
      \VExp{\uparrow}{
        B_\SortCan,
        \VExp{cdr}{R}
      }
    }
  }
  \and
  \inferrule[CdrCoeSg]{
    \Car{M}{M_0}
    \\
    \Cdr{M}{M_1}
    \\
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\\\
    \InstClo{B_\SortBClo}{
      \VExp{coe}{
        \ThinVal{\ThinSkip{\ThinId}}{I},
        \Atom{0},
        \ThinVal{\ThinKeep{\ThinSkip{\ThinId}}}{A_\SortCan},
        \ThinVal{\ThinSkip{\ThinId}}{M_0}
      }
    }{B_\SortCan}
  }{
    \Cdr{
      \VExp{coe}{
        I,
        J,
        \VExp{\Sigma}{
          A_\SortClo,
          B_\SortBClo%
        },
        M
      }
    }{
      \VExp{coe}{
        I,
        J,
        B_\SortCan,
        M_1
      }
    }
  }
\end{mathparpagebreakable}


\section{Quotation}

\newcommand\QuoteCan[4]{
  \FmtVal{#1}\vDash\FmtVal{#2}\ni\FmtVal{#3}\Uparrow\FmtTm{#4}
}

\newcommand\QuoteNeu[4]{
  \FmtVal{#1}\vDash\FmtVal{#2}\Uparrow\FmtTm{#3}\in\FmtVal{#4}
}

\newcommand\SortCtx[1]{\FmtKwd{ctx}_{#1}}

\subsection{Semantic contexts}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgCtx]{}{
      \DeclBox{\IsVal{n^-}{\Gamma}{\SortCtx{l^-}}}
    }
  }
  \\
  \inferrule[CtxNil]{}{
    \IsVal{0}{\cdot}{\SortCtx{0}}
  }
  \and
  \inferrule[CtxExtVar]{
    \IsVal{n}{\Gamma}{\SortCtx{l}}
    \\
    \IsVal{n}{A}{\SortCan}
  }{
    \IsVal{n}{\Gamma.A}{\SortCtx{l+1}}
  }
  \and
  \inferrule[CtxExtAtom]{
    \IsVal{n}{\Gamma}{\SortCtx{l}}
    \\
    \IsVal{n}{A}{\SortCan}
  }{
    \IsVal{n+1}{\Gamma.\nabla{}A}{\SortCtx{l}}
  }
\end{mathparpagebreakable}

\subsection{Quotation and Definitional Equivalence}

To start with, I define a quotation from semantic values to syntactic
terms; together with evaluation, this generates a theory of
definitional equivalence. However, this is an inefficient way to
calculate definitional equivalence (the negative cases can be
devastating); worse, later on we will introduce programming constructs
(such as systems) which resist a sensible notion of normal form. As
such, the quotation algorithm defined below will serve as a template
for a binary generalization that checks definitional equivalence.

\newcommand\LookupAtom[4]{\FmtVal{#1}\ni\Atom{#2}:\Squares*{\FmtThin{#4}*\FmtVal{#3}}}
\newcommand\LookupVar[4]{\FmtVal{#1}\ni\Var{#2}:\Squares*{\FmtThin{#4}*\FmtVal{#3}}}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgQuoteCan]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      \IsVal{n}{A}{\SortCan}
      \\
      \IsVal{n}{M}{\SortCan}
      \\
      \IsTm{n}{l}{M}{\SortChk}
    }{
      \DeclBox{\QuoteCan{\Gamma^+}{A^+}{M^+}{M^-}}
    }
  }
  \and
  \DeclBox{
    \inferrule[JdgQuoteNeu]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      \IsVal{n}{R}{\SortNeu}
      \\
      \IsTm{n}{l}{R}{\SortInf}
      \\
      \IsVal{n}{A}{\SortCan}
    }{
      \DeclBox{\QuoteNeu{\Gamma^+}{R^+}{R^-}{A^-}}
    }
  }
  \\
  \inferrule[QuotePi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \QuoteCan{\Gamma}{C}{A_\SortCan}{A}
    \\
    \InstClo{B_\SortClo}{
      \Var{\Len{\Gamma}}
    }{
      B_\SortCan{}
    }
    \\
    \QuoteCan{\Gamma.A_\SortCan}{C}{B_\SortCan}{B}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{\Pi}{A_\SortClo,B_\SortBClo}
    }{
      \TExp{\Pi}{
        A,
        B
      }
    }
  }
  \and
  \inferrule[QuoteLam]{
    \EvalClo{A}{A_\SortCan}
    \\
    \InstClo{B}{\Var{\Len{\Gamma}}}{B_\SortCan}
    \\
    \Apply{M}{\Var{\Len{\Gamma}}}{N}
    \\
    \QuoteCan{\Gamma.A_\SortCan}{B_\SortCan}{N}{N}
  }{
    \QuoteCan{\Gamma}{
      \VExp{\Pi}{A,B}
    }{M}{
      \TExp{\lambda}{N}
    }
  }
  \and
  \inferrule[QuoteCoeBool]{
    \QuoteCan{\Gamma}{\Bool}{M}{M}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{coe}{
        I,
        J,
        \Bool,
        M
      }
    }{
      M
    }
  }
  \and
  \inferrule[QuoteCoeUp]{
    \QuoteCan{\Gamma}{\Interval}{I}{I}
    \\
    \QuoteCan{\Gamma}{\Interval}{J}{J}
    \\\\
    \QuoteNeu{\Gamma.\nabla\Interval}{R}{R}{A'}
    \\
    \QuoteCan{\Gamma.\nabla\Interval}{\FmtKwd{U}}{A'}{A'}
    \\\\
    \PushSubstA{\ThinId}{
      \ThinRep{\ThinId}{
        \TExp{\downarrow}{
          \Interval,
          I
        }
      }
    }{A'}{A_I}
    \\
    \Eval{\ThinId}{\ThinId}{\parallel\Gamma\parallel}{A_I}{A_I}
    \\
    \QuoteCan{\Gamma}{A_I}{M}{M}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{coe}{
        I,
        J,
        \VExp{\uparrow}{A,R},
        M
      }
    }{
      \TExp{\uparrow}{
        \TExp{coe}{
          I,
          J,
          \TExp{\uparrow}{R},
          M
        }
      }
    }
  }
  \and
  \inferrule[QuoteAtom]{
    \LookupAtom{\Gamma}{i}{A}{f}
  }{
    \QuoteNeu{\Gamma}{\Atom{i}}{\Atom{i}}{\ThinVal{f}{A}}
  }
  \and
  \inferrule[QuoteVar]{
    \FmtTm{i}\equiv{\FmtTm{\Len{\FmtVal{\Gamma}}-\Parens*{\FmtVal{l}+1}}}
    \\
    \LookupVar{\Gamma}{i}{A}{f}
  }{
    \QuoteNeu{\Gamma}{\Var{l}}{
      \Var{i}
    }{
      \ThinVal{f}{A}
    }
  }
  \and
  \inferrule[QuoteApPi]{
    \QuoteNeu{\Gamma}{R}{R}{
      \VExp{\Pi}{A_\SortClo,B_\SortBClo}
    }
    \\
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortBClo}{N}{B_\SortCan}
    \\
    \QuoteCan{\Gamma}{A_\SortCan}{N}{N}
  }{
    \QuoteNeu{\Gamma}{
      \VExp{@}{R,N}
    }{
      \TExp{@}{R,N}
    }{
      B_\SortCan%
    }
  }
  \and
  \inferrule[QuoteApPath]{
    \QuoteNeu{\Gamma}{R}{R}{
      \VExp{path}{A_\SortBClo,M_0,M_1}
    }
    \\
    \InstClo{A_\SortClo}{N}{A_\SortCan}
    \\
    \QuoteCan{\Gamma}{\Interval}{N}{N}
  }{
    \QuoteNeu{\Gamma}{
      \VExp{@}{R,N}
    }{
      \TExp{@}{R,N}
    }{
      A_\SortCan%
    }
  }
  \and
  \inferrule[QuoteCar]{
    \QuoteNeu{\Gamma}{R}{R}{
      \VExp{\Sigma}{A_\SortClo,B_\SortBClo}
    }
    \\
    \EvalClo{A_\SortClo}{A_\SortCan}
  }{
    \QuoteNeu{\Gamma}{
      \VExp{car}{R}
    }{
      \TExp{car}{R}
    }{A_\SortCan}
  }
  \and
  \inferrule[QuoteCdr]{
    \QuoteNeu{\Gamma}{R}{R}{
      \VExp{\Sigma}{A_\SortClo,B_\SortBClo}
    }
    \\
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortBClo}{
      \VExp{\uparrow}{
        A_\SortCan,
        \VExp{car}{R}
      }
    }{B_\SortCan}
  }{
    \QuoteNeu{\Gamma}{
      \VExp{cdr}{R}
    }{
      \TExp{cdr}{R}
    }{
      B_\SortCan%
    }
  }
\end{mathparpagebreakable}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgLookupAtom]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      i<n
      \\
      \IsThin{f}{n}{m}
      \\
      \IsVal{m}{A}{\SortCan}
    }{
      \DeclBox{\LookupAtom{\Gamma^+}{i^+}{A^-}{f^-}}
    }
  }
  \quad
  \DeclBox{
    \inferrule[JdgLookupVar]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      i<l
      \\
      \IsThin{f}{n}{m}
      \\
      \IsVal{m}{A}{\SortCan}
    }{
      \DeclBox{\LookupVar{\Gamma^+}{i^+}{A^-}{f^-}}
    }
  }
  \\
  \inferrule[LookupAtomVar]{
    \LookupAtom{\Gamma}{i}{A}{f}
  }{
    \LookupAtom{\Gamma.B}{i}{A}{f}
  }
  \and
  \inferrule[LookupAtomHere]{}{
    \LookupAtom{\Gamma.\nabla{}A}{0}{A}{\ThinId}
  }
  \and
  \inferrule[LookupAtomThere]{
    \LookupAtom{\Gamma}{n}{A}{f}
  }{
    \LookupAtom{\Gamma.\nabla{}A}{n+1}{A}{\ThinSkip{f}}
  }
  \\
  \inferrule[LookupVarAtom]{
    \LookupVar{\Gamma}{n}{A}{f}
  }{
    \LookupVar{\Gamma.\nabla{}B}{n}{A}{\ThinSkip{f}}
  }
  \and
  \inferrule[LookupVarHere]{}{
    \LookupVar{\Gamma.A}{0}{A}{\ThinId}
  }
  \and
  \inferrule[LookupVarThere]{
    \LookupVar{\Gamma}{n}{A}{f}
  }{
    \LookupVar{\Gamma.B}{n+1}{A}{f}
  }
\end{mathparpagebreakable}


\nocite{abel-coquand-pagano:2009, abel-vezzosi-winterhalter:2017, abcfhl:2017, cchm:2017, altenkirch-mcbride:2006, altenkirch-mcbride-swierstra:2007, stone-harper:2006, angiuli-favonia-harper:2017}

\bibliographystyle{plainnat}
\bibliography{references/refs}

\end{document}
