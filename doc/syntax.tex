\documentclass{article}
\usepackage{amssymb}

\usepackage[tt=false]{libertine}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{mathpartir}
\usepackage[dvipsnames]{xcolor}
\usepackage{fullpage}

\usepackage{mathtools}

\DeclarePairedDelimiter\Parens{\lparen}{\rparen}
\DeclarePairedDelimiter\Angles{\langle}{\rangle}
\DeclarePairedDelimiter\Squares{[}{]}

\DeclarePairedDelimiter\Braces{\lbrace}{\rbrace}
\DeclarePairedDelimiter\Pipes{\lvert}{\rvert}

\newcommand\Len[1]{\Pipes*{#1}}

\newtheorem{remark}{Remark}



\usepackage{stmaryrd}

\title{Cubical Equality: Syntax}
\author{Jon Sterling}

\newcommand\FmtKwd[1]{\mathsf{#1}}

\newcommand\DeclBox[1]{\framebox{$\displaystyle{}#1$}}
\newcommand\FmtThin[1]{{\color{ProcessBlue}#1}}
\newcommand\XThin[3]{{#2}\rightarrowtriangle_{#1}{#3}}

\newcommand\Thin[2]{{#1}\rightarrowtriangle{#2}}
\newcommand\IsThin[3]{\FmtThin{#1}:\Thin{#2}{#3}}
\newcommand\IsXThin[4]{\FmtThin{#1}:\XThin{#2}{#3}{#4}}

\newcommand\ThinId{\mathsf{id}}
\newcommand\ThinKeep[1]{{#1}.\mathsf{c}}
\newcommand\ThinSkip[1]{{#1}.\mathsf{p}}
\newcommand\ThinRep[2]{{#1}.\Squares*{{\normalcolor{}#2}}}

\usepackage{xinttools}

\newcommand\FormatList[3]{%
  \xintFor ##1 in {#3} \do{%
    #1{##1}%
    \xintifForLast{}{#2}
  }
}



\newcommand\THIN{\mathbf{Thin}}
\newcommand\OpCat[1]{{#1}^{\mathsf{op}}}
\newcommand\SET{\mathbf{Set}}

\newcommand\Interval{\FmtKwd{dim}}
\newcommand\Bool{\FmtKwd{bool}}
\newcommand\Atom[1]{{\boldsymbol\alpha}_{#1}}
\newcommand\Var[1]{\mathsf{v}_{#1}}

\newcommand\SortChk{\FmtKwd{chk}}
\newcommand\SortInf{\FmtKwd{inf}}

\newcommand\Tm[3]{{#1}\mid{#2}\vdash{#3}}
\newcommand\FmtTm[1]{{\color{Violet}#1}}
\newcommand\IsTm[4]{{#1}\mid{#2}\vdash\FmtTm{#3}:{#4}}
\newcommand\IsChk[3]{\IsTm{#1}{#2}{#3}{\SortChk}}
\newcommand\IsInf[3]{\IsTm{#1}{#2}{#3}{\SortInf}}

\newcommand\TExp[2]{
  \FmtTm{
    \Parens*{
      \FmtKwd{#1}\
      \FormatList{}{\ }{#2}
    }
  }
}


\newcommand\FmtVal[1]{{\color{Red}{#1}}}

\newcommand\VExp[2]{
  \FmtVal{
    \Parens*{
      \FmtKwd{#1}\
      \FormatList{}{\ }{#2}
    }
  }
}



\begin{document}
\maketitle

In these notes, we use colors to distinguish objects of different
(meta) sorts from each other, in order to avoid getting lost in a
hurricane of superscripts. As such, $\FmtTm{M}$ and $\FmtVal{M}$ are
to be understood as distinct schematic variables.

Some of the ideas for dealing with evaluation under dimension binders
come from joint work with Favonia; the idea of generalized thinnings
comes from Conor McBride (as far as I am aware).


\section{Thinnings}

$X$-Thinnings are a defunctionalized representation of substitutions
which capture the idea of deleting some variables from within a
context, or possibly replacing them with an element of the family
$X:\SET^{\mathbb{N}}$. When $X$ is the empty family, these correspond
to the \emph{order-preserving embeddings} of Chapman.
%
We choose a representation of thinnings which lends itself to
efficient calculation, but is not canonical; therefore, any operation
on thinnings must be proved to be respect the algebraic laws of
thinnings in order to be well-defined.
\begin{mathparpagebreakable}
  \DeclBox{
    \IsXThin{f}{X}{m}{n}
  }
  \\
  \inferrule{
  }{
    \IsXThin{\ThinId}{X}{n}{n}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{m}{n}
  }{
    \IsXThin{\ThinKeep{f}}{X}{m+1}{n+1}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{m}{n}
  }{
    \IsXThin{\ThinSkip{f}}{X}{m+1}{n}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{m}{n}
    \\
    a:X_m
  }{
    \IsXThin{\ThinRep{f}{a}}{X}{m}{n+1}
  }
\end{mathparpagebreakable}

We will write $\THIN$ for the category of $\varnothing$-thinnings
induced by the above. To simplify notation, we write $\Thin{m}{n}$ for
$\XThin{\varnothing}{m}{n}$.

\section{Terms}


In our term language, we distinguish between \emph{atoms} and
\emph{variables}, and their respective binders. Variable binders are
given operational meaning through substitution, whereas atom binders
are subject to open evaluation. Most binders are variable binders; the
only atom binder in our language comes from $\FmtKwd{coe}$.

\begin{remark}
  This is a matter of some subtlety in the context of
  \emph{normalization-by-evaluation} in which the evaluation and
  quotation phases of computation are distinguished: while we do not
  evaluate underneath a variable binder, during the quotation phase we
  \emph{do} instantiate such a variable binder with a semantic
  indeterminate or generic element: so, even though we end up
  transforming the interior of the binder, this is still done through
  substitution. In contrast, we do evaluate underneath atom binders.
\end{remark}

Terms are classified by sorts $\tau\in\Braces*{\SortChk,\SortInf}$; we
will write the judgment $\IsTm{n}{l}{M}{\tau}$ to mean that
$\FmtTm{M}$ is a term of sort $\tau$ with $n$ atoms and $l$
variables. In the term language, both atoms and variables are managed
using De Bruijn indices. An illustrative fragment of the syntax is
presented below.

\begin{mathparpagebreakable}
  \DeclBox{
    \IsTm{n}{l}{M}{\tau}
  }
  \\
  \and
  \inferrule[TmAtom]{
    i<n
  }{
    \IsInf{n}{l}{\Atom{i}}
  }
  \and
  \inferrule[TmVar]{
    i<l
  }{
    \IsInf{n}{l}{\Var{i}}
  }
  \and
  \inferrule[TmPi]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l+1}{B}
  }{
    \IsChk{n}{l}{
      \TExp{\Pi}{A,B}
    }
  }
  \and
  \inferrule[TmSg]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l+1}{B}
  }{
    \IsChk{n}{l}{
      \TExp{\Sigma}{A,B}
    }
  }
  \and
  \inferrule[TmEq]{
    \IsChk{n}{l+1}{A}
    \\
    \IsChk{n}{l}{M}
    \\
    \IsChk{n}{l}{N}
  }{
    \IsChk{n}{l}{
      \TExp{eq}{A,M,N}
    }
  }
  \and
  \inferrule[TmLam]{
    \IsChk{n}{l+1}{M}
  }{
    \IsChk{n}{l}{\TExp{\lambda}{M}}
  }
  \and
  \inferrule[TmCons]{
    \IsChk{n}{l}{M}
    \\
    \IsChk{n}{l}{N}
  }{
    \IsChk{n}{l}{\TExp{cons}{M,N}}
  }
  \and
  \inferrule[TmCar]{
    \IsInf{n}{l}{R}
  }{
    \IsInf{n}{l}{\TExp{car}{R}}
  }
  \and
  \inferrule[TmCdr]{
    \IsInf{n}{l}{R}
  }{
    \IsInf{n}{l}{\TExp{cdr}{R}}
  }
  \and
  \inferrule[TmDim0]{
  }{
    \IsChk{n}{l}{0}
  }
  \and
  \inferrule[TmDim1]{
  }{
    \IsChk{n}{l}{1}
  }
  \and
  \inferrule[TmUp]{
    \IsInf{n}{l}{R}
  }{
    \IsChk{n}{l}{\TExp{\uparrow}{R}}
  }
  \and
  \inferrule[TmApp]{
    \IsInf{n}{l}{R}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{\TExp{@}{R,M}}
  }
  \and
  \inferrule[TmDown]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{\TExp{\downarrow}{A,M}}
  }
  \and
  \inferrule[TmCoe]{
    \IsChk{n}{l}{I}
    \\
    \IsChk{n}{l}{J}
    \\
    \IsChk{n+1}{l}{A}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{
      \TExp{coe}{
        I,
        J,
        A,
        M
      }
    }
  }
\end{mathparpagebreakable}

Note that altogether the definition above forms a family of functors
$\Parens*{\Tm{\square}{l}{\tau}}:\OpCat{\THIN}\to\SET$, whose
functorial action is the renaming of atoms.

\section{Semantic Domain}

The semantic domain of our language is really another syntax, in which
variables are replaced by semantic indeterminates (represented as De
Bruijn levels), and atoms remain represented as De Bruijn indices. The
semantic domain captures the weak-head normal forms of our language;
because we intend to develop a substitution-free operational semantics
using environments, we must naturally employ a notion of
\emph{closure}.

\newcommand\SortCan{\FmtKwd{can}}
\newcommand\SortNeu{\FmtKwd{neu}}
\newcommand\SortNf{\FmtKwd{nf}}
\newcommand\SortClo{\FmtKwd{clo}}
\newcommand\SortBClo{\FmtKwd{bclo}}
\newcommand\SortEnv[1]{\FmtKwd{env}_{#1}}
\newcommand\IsVal[3]{{#1}\Vdash\FmtVal{#2}:{#3}}
\newcommand\Val[2]{{#1}\Vdash{#2}}

\newcommand\Clo[4]{
  \Squares*{
    \FmtThin{#1}%
    \mathbin{\color{gray}*}%
    \Angles*{
      \FmtTm{#4}
      \mathbin{\color{gray}\triangleleft}%
      \FmtThin{#2}
      \mathbin{\color{gray}*}%
      \FmtVal{#3}
    }
  }
}

\newcommand\BClo[4]{
  \Squares*{
    \FmtThin{#1}%
    \mathbin{\color{gray}*}%
    \Angles*{
      \FmtTm{#4}
      \mathbin{\color{gray}\triangleleft^+}%
      \FmtThin{#2}
      \mathbin{\color{gray}*}%
      \FmtVal{#3}
    }
  }
}


Values are classified by sorts
$\tau\in\Braces*{\SortCan,\SortNeu,\SortNf,\SortEnv{l},\SortClo,\SortBClo}$; for
such a sort $\tau$, we will write $\IsVal{n}{M}{\tau}$ to mean that
$\FmtVal{M}$ is a value of sort $\tau$ with $n$ atoms. We no longer
track the number of variables, because these are replaced by
indeterminates in the form of De Bruijn levels (which have an absolute
reference).

\begin{mathparpagebreakable}
  \DeclBox{
    \IsVal{n}{M}{\tau}
  }
  \\
  \inferrule[ValAtom]{
    i<n
  }{
    \IsVal{n}{\Atom{i}}{\SortCan}
  }
  \and
  \inferrule[ValGen]{
  }{
    \IsVal{n}{\Var{l}}{\SortNeu}
  }
  \and
  \inferrule[ValDown]{
    \IsVal{n}{A}{\SortCan}
    \\
    \IsVal{n}{M}{\SortCan}
  }{
    \IsVal{n}{
      \VExp{\downarrow}{A,M}
    }{\SortNf}
  }
  \and
  \inferrule[ValUp]{
    \IsVal{n}{A}{\SortCan}
    \\
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{
      \VExp{\uparrow}{A,R}
    }{\SortCan}
  }
  \and
  \inferrule[ValClo]{
    \IsXThin{g}{\Parens*{\Val{\square}{\SortCan}}}{o}{n}
    \\
    \IsXThin{f}{\Parens*{\Val{\square}{\SortCan}}}{n}{m}
    \\
    \IsVal{m}{\rho}{\SortEnv{l}}
    \\
    \IsTm{n}{l}{M}{\SortChk}
  }{
    \IsVal{o}{
      \Clo{g}{f}{\rho}{M}
    }{\SortClo}
  }
  \and
  \inferrule[ValBClo]{
    \IsXThin{g}{\Parens*{\Val{\square}{\SortCan}}}{o}{n}
    \\
    \IsXThin{f}{\Parens*{\Val{\square}{\SortCan}}}{n}{m}
    \\
    \IsVal{m}{\rho}{\SortEnv{l}}
    \\
    \IsTm{n}{l+1}{M}{\SortChk}
  }{
    \IsVal{o}{
      \BClo{g}{f}{\rho}{M}
    }{\SortBClo}
  }
  \and
  \inferrule[ValEnv]{
    \forall{i<l}.\ \IsVal{n}{M_i}{\SortCan}
  }{
    \IsVal{n}{\Squares{M_i}_{i<l}}{\SortEnv{l}}
  }
  \\
  \inferrule[ValPi]{
    \IsVal{n}{A}{\SortClo}
    \\
    \IsVal{n}{A}{\SortBClo}
  }{
    \IsVal{n}{
      \VExp{\Pi}{A,B}
    }{\SortCan}
  }
  \and
  \inferrule[ValLam]{
    \IsVal{n}{M}{\SortClo}
  }{
    \IsVal{n}{\VExp{\lambda}{M}}{\SortCan}
  }
  \and
  \inferrule[ValApp]{
    \IsVal{n}{R}{\SortNeu}
    \\
    \IsVal{n}{M}{\SortNf}
  }{
    \IsVal{n}{\VExp{@}{R,M}}{\SortNeu}
  }
  \and
  \inferrule[ValCons]{
    \IsVal{n}{M}{\SortClo}
    \\
    \IsVal{n}{N}{\SortClo}
  }{
    \IsVal{n}{\VExp{cons}{M,N}}{\SortCan}
  }
  \and
  \inferrule[ValCar]{
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{\VExp{car}{R}}{\SortNeu}
  }
  \and
  \inferrule[ValCdr]{
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{\VExp{cdr}{R}}{\SortNeu}
  }
  \and
  \inferrule[ValCoe]{
    \IsVal{n}{I}{\SortCan}
    \\
    \IsVal{n}{J}{\SortCan}
    \\
    \IsVal{n+1}{A}{\SortCan}
    \\
    \IsVal{n}{M}{\SortCan}
  }{
    \IsVal{n}{
      \VExp{coe}{I,J,A,M}
    }{\SortCan}
  }
\end{mathparpagebreakable}


The syntax of values can be reindexed contravariantly along
value-thinnings $\IsXThin{f}{\Val{\square}{\SortCan}}{m}{n}$; the
reindexing action is substitution; this also renders the collection of
value-thinnings into a category.

\begin{remark}
  It may seem strange that we have a substitution operation on
  semantic values, since values usually come from an environment, and
  also embed an environment in their closures. However, the
  substitution action is necessary to explain descent under
  \emph{atom} binders such as those found in $\FmtKwd{coe}$ values.

  Substitution on values is very inexpensive, because in each case,
  the substitution hits a closure and gets suspended: the action of
  substitution on closures is composition with the suspended thinning.
\end{remark}



\section{Evaluation}
\newcommand\EvalClo[2]{\FmtVal{#1}\Downarrow\FmtVal{#2}}
\newcommand\Eval[5]{\FmtThin{#2}*\FmtVal{#3}\vDash\FmtTm{#4}\mathrel{\Downarrow_{\FmtThin{#1}}}\FmtVal{#5}}
\newcommand\Apply[3]{\FmtVal{#1}\mathrel{@}\FmtVal{#2}\Downarrow\FmtVal{#3}}
\newcommand\InstClo[3]{\FmtVal{#1}\bullet\FmtVal{#2}\Downarrow\FmtVal{#3}}
\newcommand\ThinVal[2]{\widehat{\FmtThin{#1}}\Parens*{\FmtVal{#2}}}

At a high level, evaluation takes terms to values; at a finer-grained
level, however, we will evaluate with respect to a thinning
$\FmtThin{g}$ and an environment $\FmtVal{\rho}$ together with a
thinning $\FmtThin{f}$; this allows us to avoid actually executing
thinnings and substitutions until the last moment possible. In fact,
the preceding sentence can be rephrased as construing evaluation as a
relation $\EvalClo{M_\SortClo}{M_\SortCan}$ where
$\IsVal{n}{M_\SortClo}{\SortClo}$ and
$\IsVal{n}{M_\SortCan}{\SortCan}$.

We will write $\Eval{g}{f}{\rho}{M}{M}$ as a notation for
$\EvalClo{\Clo{g}{f}{\rho}{M}}{M}$, when it is well-formed:

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgEval]{
      \IsXThin{g}{\Parens*{\Val{\square}{\SortCan}}}{o}{n}
      \\
      \IsXThin{f}{\Parens*{\Val{\square}{\SortCan}}}{n}{m}
      \\
      \IsVal{m}{\rho}{\SortEnv{l}}
      \\
      \IsTm{n}{l}{M}{\tau}
      \\
      \IsVal{o}{M}{\SortCan}
    }{
      \DeclBox{
        \Eval{g^+}{f^+}{\rho^+}{M^+}{M^-}
      }
    }
  }
  \\
  \inferrule[EvalAtom]{}{
    \Eval{g}{f}{\rho}{\Atom{i}}{
      \ThinVal{g}{\Atom{i}}
    }
  }
  \and
  \inferrule[EvalVar]{}{
    \Eval{g}{f}{\rho}{\Var{l}}{
      \ThinVal{
        g\circ{}f
      }{\rho_l}
    }
  }
  \and
  \inferrule[EvalPi]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\Pi}{A,B}
    }{
      \VExp{\Pi}{
        \Clo{g}{f}{\rho}{A},
        \BClo{g}{f}{\rho}{B}
      }
    }
  }
  \and
  \inferrule[EvalSg]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\Sigma}{A,B}
    }{
      \VExp{\Sigma}{
        \Clo{g}{f}{\rho}{A},
        \BClo{g}{f}{\rho}{B}
      }
    }
  }
  \and
  \inferrule[EvalEq]{}{
    \Eval{g}{f}{\rho}{
      \TExp{eq}{A,M,N}
    }{
      \VExp{eq}{
        \BClo{g}{f}{\rho}{A},
        \Clo{g}{f}{\rho}{M},
        \Clo{g}{f}{\rho}{N}
      }
    }
  }
  \and
  \inferrule[EvalLam]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\lambda}{M}
    }{
      \VExp{\lambda}{
        \BClo{g}{f}{\rho}{M}
      }
    }
  }
  \and
  \and
  \inferrule[EvalUp]{
    \Eval{g}{f}{\rho}{R}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{\uparrow}{R}
    }{
      M
    }
  }
  \and
  \inferrule[EvalDown]{
    \Eval{g}{f}{\rho}{M}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{\downarrow}{A,M}
    }{M}
  }
  \and
  \inferrule[EvalCoe]{
    \Eval{g}{f}{\rho}{I}{I}
    \\
    \Eval{g}{f}{\rho}{J}{J}
    \\
    \Eval{\ThinKeep{g}}{\ThinSkip{f}}{\rho}{A}{A}
    \\
    \Eval{g}{f}{\rho}{M}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{coe}{I,J,A,M}
    }{
      \VExp{coe}{
        I,
        J,
        A,
        M
      }
    }
  }
  \and
  \inferrule[EvalApp]{
    \Eval{g}{f}{\rho}{R}{M_{\mathsf{fun}}}
    \\
    \Eval{g}{f}{\rho}{M}{M_{\mathsf{arg}}}
    \\
    \Apply{M_{\mathsf{fun}}}{M_{\mathsf{arg}}}{N}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{@}{
        R,
        M
      }
    }{
      N
    }
  }
\end{mathparpagebreakable}


\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgInst]{
      \IsVal{n}{M}{\SortBClo}
      \\
      \IsVal{n}{N}{\SortCan}
      \\
      \IsVal{n}{O}{\SortCan}
    }{
      \DeclBox{\InstClo{M^+}{N^+}{O^-}}
    }
  }
  \and
  \inferrule[InstBClo]{
    \Eval{g}{f}{\Squares*{N,\rho}}{M}{O}
  }{
    \InstClo{
      \BClo{g}{f}{\rho}{M}
    }{N}{O}
  }
\end{mathparpagebreakable}


\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgApply]{
      \IsVal{n}{M}{\SortCan}
      \\
      \IsVal{n}{N}{\SortCan}
      \\
      \IsVal{n}{O}{\SortCan}
    }{
      \DeclBox{\Apply{M^+}{N^+}{O^-}}
    }
  }
  \\
  \inferrule[ApplyLam]{
    \InstClo{M}{N}{O}
  }{
    \Apply{\VExp{\lambda}{M}}{N}{O}
  }
  \and
  \inferrule[ApplyUpPi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortClo}{N}{B_\SortCan}
  }{
    \Apply{
      \VExp{\uparrow}{
        \VExp{\Pi}{A_\SortClo,B_\SortBClo},
        R
      }
    }{N}{
      \VExp{\uparrow}{
        B_\SortCan,
        \VExp{@}{
          R,
          \VExp{\downarrow}{
            A_\SortCan,
            N
          }
        }
      }
    }
  }
  \and
  \inferrule[ApplyCoePi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortBClo}{
      \VExp{coe}{
        \ThinVal{\ThinSkip{\ThinId}}{J},
        \Atom{0},
        \ThinVal{
          \ThinKeep{\ThinSkip{\ThinId}}
        }{A_\SortCan},
        \ThinVal{\ThinSkip{\ThinId}}{N}
      }
    }{
      B_\SortCan{}
    }
    \\
    \Apply{M}{
      \VExp{coe}{
        J,
        I,
        A_\SortCan,
        N
      }
    }{O}
  }{
    \Apply{
      \VExp{coe}{
        I,
        J,
        \VExp{\Pi}{A_\SortClo,B_\SortBClo},
        M
      }
    }{N}{
      \VExp{coe}{
        I,
        J,
        B_\SortCan,
        O
      }
    }
  }
\end{mathparpagebreakable}


\section{Quotation}

\newcommand\QuoteCan[4]{
  \FmtVal{#1}\vDash\FmtVal{#2}\ni\FmtVal{#3}\Uparrow\FmtTm{#4}
}

\newcommand\QuoteNeu[4]{
  \FmtVal{#1}\vDash\FmtVal{#2}\Uparrow\FmtTm{#3}\in\FmtVal{#4}
}

\newcommand\SortCtx[1]{\FmtKwd{ctx}_{#1}}

\subsection{Semantic contexts}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgCtx]{}{
      \DeclBox{\IsVal{n^-}{\Gamma}{\SortCtx{l^-}}}
    }
  }
  \\
  \inferrule[CtxNil]{}{
    \IsVal{0}{\cdot}{\SortCtx{0}}
  }
  \and
  \inferrule[CtxExtVar]{
    \IsVal{n}{\Gamma}{\SortCtx{l}}
    \\
    \IsVal{n}{A}{\SortCan}
  }{
    \IsVal{n}{\Gamma.A}{\SortCtx{l+1}}
  }
  \and
  \inferrule[CtxExtAtom]{
    \IsVal{n}{\Gamma}{\SortCtx{l}}
    \\
    \IsVal{n}{A}{\SortCan}
  }{
    \IsVal{n+1}{\Gamma.\nabla{}A}{\SortCtx{l}}
  }
\end{mathparpagebreakable}

\subsection{Quotation}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgQuoteCan]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      \IsVal{n}{A}{\SortCan}
      \\
      \IsVal{n}{M}{\SortCan}
      \\
      \IsTm{n}{l}{M}{\SortChk}
    }{
      \DeclBox{\QuoteCan{\Gamma^+}{A^+}{M^+}{M^-}}
    }
  }
  \and
  \DeclBox{
    \inferrule[JdgQuoteNeu]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      \IsVal{n}{R}{\SortNeu}
      \\
      \IsTm{n}{l}{M}{\SortNeu}
      \\
      \IsVal{n}{l}{A_\SortCan}
    }{
      \DeclBox{\QuoteNeu{\Gamma^+}{R^+}{R^-}{A^-}}
    }
  }
  \\
  \inferrule[QuotePi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \QuoteCan{\Gamma}{C}{A_\SortCan}{A}
    \\
    \InstClo{B_\SortClo}{
      \Var{\Len{\Gamma}}
    }{
      B_\SortCan{}
    }
    \\
    \QuoteCan{\Gamma.A_\SortCan}{C}{B_\SortCan}{B}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{\Pi}{A_\SortClo,B_\SortBClo}
    }{
      \TExp{\Pi}{
        A,
        B
      }
    }
  }
  \and
  \inferrule[QuoteLam]{
    \EvalClo{A}{A_\SortCan}
    \\
    \InstClo{B}{\Var{\Len{\Gamma}}}{B_\SortCan}
    \\
    \Apply{M}{\Var{\Len{\Gamma}}}{N}
    \\
    \QuoteCan{\Gamma.A_\SortCan}{B_\SortCan}{N}{N}
  }{
    \QuoteCan{\Gamma}{
      \VExp{\Pi}{A,B}
    }{M}{
      \TExp{\lambda}{N}
    }
  }
  \and
  \inferrule[QuoteCoeBool]{
    \QuoteCan{\Gamma}{\Bool}{M}{M}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{coe}{
        I,
        J,
        \Bool,
        M
      }
    }{
      M
    }
  }
  \and
  \inferrule[QuoteCoeUp]{
    \QuoteCan{\Gamma}{\Interval}{I}{I}
    \\
    \QuoteCan{\Gamma}{\Interval}{J}{J}
    \\
    \QuoteNeu{\Gamma.\nabla\Interval}{R}{R}{A'}
    \\
    \QuoteCan{\Gamma}{
      \ThinVal{
        \ThinRep{\ThinId}{\FmtVal{I}}
      }{A'}
    }{M}{M}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{coe}{
        I,
        J,
        \VExp{\uparrow}{A,R},
        M
      }
    }{
      \TExp{\uparrow}{
        \TExp{coe}{
          I,
          J,
          \TExp{\uparrow}{R},
          M
        }
      }
    }
  }
\end{mathparpagebreakable}

\end{document}
